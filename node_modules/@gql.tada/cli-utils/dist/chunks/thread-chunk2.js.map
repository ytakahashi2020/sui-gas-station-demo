{"version":3,"file":"thread-chunk2.js","sources":["../../src/commands/turbo/thread.ts"],"sourcesContent":["import ts from 'typescript';\nimport * as path from 'node:path';\nimport type { GraphQLSPConfig } from '@gql.tada/internal';\n\nimport { getSchemaNamesFromConfig } from '@gql.tada/internal';\nimport { findAllCallExpressions } from '@0no-co/graphqlsp/api';\n\nimport { programFactory } from '../../ts';\nimport { expose } from '../../threads';\n\nimport type {\n  TurboSignal,\n  TurboWarning,\n  TurboDocument,\n  GraphQLSourceFile,\n  GraphQLSourceImport,\n  TurboPath,\n} from './types';\n\nexport interface TurboParams {\n  rootPath: string;\n  configPath: string;\n  pluginConfig: GraphQLSPConfig;\n  turboOutputPath: string | TurboPath[];\n}\n\nfunction traceCallToImportSource(\n  callExpression: ts.CallExpression,\n  sourceFile: ts.SourceFile,\n  program: ts.Program\n): string | undefined {\n  const typeChecker = program.getTypeChecker();\n  const expression = callExpression.expression;\n\n  let identifier: ts.Identifier | undefined;\n  if (ts.isIdentifier(expression)) {\n    identifier = expression;\n  } else if (ts.isPropertyAccessExpression(expression) && ts.isIdentifier(expression.expression)) {\n    identifier = expression.expression;\n  }\n\n  if (!identifier) return undefined;\n\n  const symbol = typeChecker.getSymbolAtLocation(identifier);\n  if (!symbol || !symbol.declarations) return undefined;\n\n  for (const declaration of symbol.declarations) {\n    const importDeclaration = findImportDeclaration(declaration);\n    if (importDeclaration && ts.isStringLiteral(importDeclaration.moduleSpecifier)) {\n      const moduleName = importDeclaration.moduleSpecifier.text;\n      return resolveModulePath(moduleName, sourceFile, program);\n    }\n  }\n\n  return undefined;\n}\n\nfunction findImportDeclaration(node: ts.Node): ts.ImportDeclaration | undefined {\n  let current: ts.Node | undefined = node;\n\n  while (current) {\n    if (ts.isImportDeclaration(current)) {\n      return current;\n    }\n    current = current.parent;\n  }\n\n  return undefined;\n}\n\nfunction resolveModulePath(\n  moduleName: string,\n  containingFile: ts.SourceFile,\n  program: ts.Program\n): string | undefined {\n  const compilerOptions = program.getCompilerOptions();\n  const host = ts.createCompilerHost(compilerOptions);\n\n  const resolved = ts.resolveModuleName(moduleName, containingFile.fileName, compilerOptions, host);\n\n  if (resolved.resolvedModule) {\n    return resolved.resolvedModule.resolvedFileName;\n  }\n\n  return undefined;\n}\n\nfunction collectImportsFromSourceFile(\n  sourceFile: ts.SourceFile,\n  pluginConfig: GraphQLSPConfig,\n  resolveModuleName: (importSpecifier: string, fromPath: string, toPath: string) => string,\n  turboOutputPath?: string\n): GraphQLSourceImport[] {\n  const imports: GraphQLSourceImport[] = [];\n\n  const tadaImportPaths = getTadaOutputPaths(pluginConfig);\n\n  function visit(node: ts.Node) {\n    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier)) {\n      const specifier = node.moduleSpecifier.text;\n\n      if (!isTadaImport(specifier, sourceFile.fileName, tadaImportPaths)) {\n        const importClause = node.getFullText().trim();\n        if (turboOutputPath) {\n          // Adjust the import specifier to point to the turbo output path\n          const adjustedSpecifier = resolveModuleName(\n            specifier,\n            sourceFile.fileName,\n            turboOutputPath\n          )\n            .replace(/\\.ts$/, '')\n            .replace(/\\.tsx$/, '');\n          if (adjustedSpecifier && !adjustedSpecifier.includes('gql.tada')) {\n            imports.push({\n              specifier: adjustedSpecifier,\n              importClause: importClause.replace(specifier, adjustedSpecifier),\n            });\n          }\n        } else {\n          imports.push({ specifier, importClause });\n        }\n      }\n    }\n    ts.forEachChild(node, visit);\n  }\n\n  visit(sourceFile);\n  return imports;\n}\n\nfunction getTadaOutputPaths(pluginConfig: GraphQLSPConfig): string[] {\n  const paths: string[] = [];\n\n  if ('schema' in pluginConfig && pluginConfig.tadaOutputLocation) {\n    paths.push(pluginConfig.tadaOutputLocation);\n  } else {\n    // Multiple schemas aren't supported in this context\n  }\n\n  return paths;\n}\n\nfunction isTadaImport(\n  importSpecifier: string,\n  sourceFilePath: string,\n  tadaOutputLocationPaths: string[]\n): boolean {\n  if (importSpecifier.startsWith('.')) {\n    const sourceDir = path.dirname(sourceFilePath);\n    const absoluteImportPath = path.resolve(sourceDir, importSpecifier);\n\n    return tadaOutputLocationPaths.some((tadaOutputLocationPath) => {\n      const absoluteTadaPath = path.resolve(tadaOutputLocationPath);\n      return (\n        absoluteImportPath === absoluteTadaPath ||\n        absoluteImportPath.startsWith(absoluteTadaPath + path.sep)\n      );\n    });\n  }\n\n  return tadaOutputLocationPaths.some(\n    (tadaPath) => importSpecifier === tadaPath || importSpecifier.startsWith(tadaPath + '/')\n  );\n}\n\nasync function* _runTurbo(params: TurboParams): AsyncIterableIterator<TurboSignal> {\n  const schemaNames = getSchemaNamesFromConfig(params.pluginConfig);\n  const factory = programFactory(params);\n\n  // NOTE: We add our override declaration here before loading all files\n  // This sets `__cacheDisabled` on the turbo cache, which disables the cache temporarily\n  // If we don't disable the cache then we couldn't regenerate it from inferred types\n  factory.addSourceFile({\n    fileId: '__gql-tada-override__.d.ts',\n    sourceText: DECLARATION_OVERRIDE,\n    scriptKind: ts.ScriptKind.TS,\n  });\n\n  const externalFiles = factory.createExternalFiles();\n  if (externalFiles.length) {\n    yield { kind: 'EXTERNAL_WARNING' };\n    await factory.addVirtualFiles(externalFiles);\n  }\n\n  const container = factory.build();\n  const pluginInfo = container.buildPluginInfo(params.pluginConfig);\n  const sourceFiles = container.getSourceFiles();\n\n  yield {\n    kind: 'FILE_COUNT',\n    fileCount: sourceFiles.length,\n  };\n\n  const checker = container.program.getTypeChecker();\n  const uniqueGraphQLSources = new Map<string, GraphQLSourceFile>();\n\n  for (const sourceFile of sourceFiles) {\n    let filePath = sourceFile.fileName;\n    const documents: TurboDocument[] = [];\n    const warnings: TurboWarning[] = [];\n\n    const calls = findAllCallExpressions(sourceFile, pluginInfo, false).nodes;\n    for (const call of calls) {\n      const callExpression = call.node.parent;\n      if (!ts.isCallExpression(callExpression)) {\n        continue;\n      }\n\n      const position = container.getSourcePosition(sourceFile, callExpression.getStart());\n      filePath = position.fileName;\n      if (!schemaNames.has(call.schema)) {\n        warnings.push({\n          message: call.schema\n            ? `The '${call.schema}' schema is not in the configuration but was referenced by document.`\n            : schemaNames.size > 1\n              ? 'The document is not for a known schema. Have you re-generated the output file?'\n              : 'Multiple schemas are configured, but the document is not for a specific schema.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      const graphqlSourcePath = traceCallToImportSource(\n        callExpression,\n        sourceFile,\n        container.program\n      );\n\n      if (graphqlSourcePath && !uniqueGraphQLSources.has(graphqlSourcePath)) {\n        const graphqlSourceFile = container.program.getSourceFile(graphqlSourcePath);\n        if (graphqlSourceFile) {\n          const turboPath = Array.isArray(params.turboOutputPath)\n            ? params.turboOutputPath.find((cfg) => cfg.schemaName === call.schema)?.path\n            : params.turboOutputPath;\n          const imports = collectImportsFromSourceFile(\n            graphqlSourceFile,\n            params.pluginConfig,\n            factory.resolveModuleName.bind(factory),\n            turboPath\n          );\n          uniqueGraphQLSources.set(graphqlSourcePath, {\n            absolutePath: graphqlSourcePath,\n            imports,\n          });\n        }\n      }\n\n      const returnType = checker.getTypeAtLocation(callExpression);\n      const argumentType = checker.getTypeAtLocation(call.node);\n      // NOTE: `returnType.symbol` is incorrectly typed and is in fact\n      // optional and not always present\n      if (!returnType.symbol || returnType.symbol.getEscapedName() !== 'TadaDocumentNode') {\n        warnings.push({\n          message:\n            `The discovered document is not of type \"TadaDocumentNode\".\\n` +\n            'If this is unexpected, please file an issue describing your case.',\n          file: position.fileName,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      const argumentKey: string =\n        'value' in argumentType &&\n        typeof argumentType.value === 'string' &&\n        (argumentType.flags & ts.TypeFlags.StringLiteral) === 0\n          ? JSON.stringify(argumentType.value)\n          : checker.typeToString(argumentType, callExpression, BUILDER_FLAGS);\n      const documentType = checker.typeToString(returnType, callExpression, BUILDER_FLAGS);\n\n      documents.push({\n        schemaName: call.schema,\n        argumentKey,\n        documentType,\n      });\n    }\n\n    yield {\n      kind: 'FILE_TURBO',\n      filePath,\n      documents,\n      warnings,\n    };\n  }\n\n  if (uniqueGraphQLSources.size > 0) {\n    yield {\n      kind: 'GRAPHQL_SOURCES',\n      sources: Array.from(uniqueGraphQLSources.values()),\n    };\n  }\n}\n\nexport const runTurbo = expose(_runTurbo);\n\nconst BUILDER_FLAGS: ts.TypeFormatFlags =\n  ts.TypeFormatFlags.NoTruncation |\n  ts.TypeFormatFlags.NoTypeReduction |\n  ts.TypeFormatFlags.InTypeAlias |\n  ts.TypeFormatFlags.UseFullyQualifiedType |\n  ts.TypeFormatFlags.GenerateNamesForShadowedTypeParams |\n  ts.TypeFormatFlags.UseAliasDefinedOutsideCurrentScope |\n  ts.TypeFormatFlags.AllowUniqueESSymbolType |\n  ts.TypeFormatFlags.WriteTypeArgumentsOfSignature;\n\nconst DECLARATION_OVERRIDE = `\nimport * as _gqlTada from 'gql.tada';\ndeclare module 'gql.tada' {\n  interface setupCache {\n    readonly __cacheDisabled: true;\n  }\n}\n`.trim();\n"],"names":["traceCallToImportSource","callExpression","sourceFile","program","typeChecker","getTypeChecker","expression","identifier","ts","isIdentifier","isPropertyAccessExpression","symbol","getSymbolAtLocation","declarations","declaration","importDeclaration","findImportDeclaration","isStringLiteral","moduleSpecifier","resolveModulePath","text","node","current","isImportDeclaration","parent","moduleName","containingFile","compilerOptions","getCompilerOptions","host","createCompilerHost","resolved","resolveModuleName","fileName","resolvedModule","resolvedFileName","collectImportsFromSourceFile","pluginConfig","turboOutputPath","imports","tadaImportPaths","getTadaOutputPaths","paths","tadaOutputLocation","push","visit","specifier","isTadaImport","importSpecifier","sourceFilePath","tadaOutputLocationPaths","startsWith","sourceDir","path","dirname","absoluteImportPath","resolve","some","tadaOutputLocationPath","absoluteTadaPath","sep","tadaPath","importClause","getFullText","trim","adjustedSpecifier","replace","includes","forEachChild","runTurbo","expose","async","_runTurbo","params","schemaNames","getSchemaNamesFromConfig","factory","programFactory","addSourceFile","fileId","sourceText","DECLARATION_OVERRIDE","scriptKind","ScriptKind","TS","externalFiles","createExternalFiles","length","kind","addVirtualFiles","container","build","pluginInfo","buildPluginInfo","sourceFiles","getSourceFiles","fileCount","checker","uniqueGraphQLSources","Map","filePath","documents","warnings","calls","findAllCallExpressions","nodes","_loop","call","isCallExpression","position","getSourcePosition","getStart","has","schema","message","size","file","line","col","graphqlSourcePath","graphqlSourceFile","getSourceFile","turboPath","Array","isArray","find","cfg","schemaName","bind","set","absolutePath","returnType","getTypeAtLocation","argumentType","getEscapedName","argumentKey","value","flags","TypeFlags","StringLiteral","JSON","stringify","typeToString","BUILDER_FLAGS","documentType","sources","from","values","TypeFormatFlags","NoTruncation","NoTypeReduction","InTypeAlias","UseFullyQualifiedType","GenerateNamesForShadowedTypeParams","UseAliasDefinedOutsideCurrentScope","AllowUniqueESSymbolType","WriteTypeArgumentsOfSignature"],"mappings":"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"}
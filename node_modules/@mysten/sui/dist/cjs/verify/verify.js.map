{
  "version": 3,
  "sources": ["../../../src/verify/verify.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64 } from '@mysten/bcs';\n\nimport type { PublicKey, SignatureFlag, SignatureScheme } from '../cryptography/index.js';\nimport { parseSerializedSignature, SIGNATURE_FLAG_TO_SCHEME } from '../cryptography/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { PasskeyPublicKey } from '../keypairs/passkey/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\n// eslint-disable-next-line import/no-cycle\nimport { MultiSigPublicKey } from '../multisig/publickey.js';\nimport type { ZkLoginCompatibleClient } from '../zklogin/publickey.js';\nimport { ZkLoginPublicIdentifier } from '../zklogin/publickey.js';\n\nexport async function verifySignature(\n\tbytes: Uint8Array,\n\tsignature: string,\n\toptions?: {\n\t\taddress?: string;\n\t},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature);\n\n\tif (!(await parsedSignature.publicKey.verify(bytes, parsedSignature.serializedSignature))) {\n\t\tthrow new Error(`Signature is not valid for the provided data`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyPersonalMessageSignature(\n\tmessage: Uint8Array,\n\tsignature: string,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyPersonalMessage(\n\t\t\tmessage,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided message`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nexport async function verifyTransactionSignature(\n\ttransaction: Uint8Array,\n\tsignature: string,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n): Promise<PublicKey> {\n\tconst parsedSignature = parseSignature(signature, options);\n\n\tif (\n\t\t!(await parsedSignature.publicKey.verifyTransaction(\n\t\t\ttransaction,\n\t\t\tparsedSignature.serializedSignature,\n\t\t))\n\t) {\n\t\tthrow new Error(`Signature is not valid for the provided Transaction`);\n\t}\n\n\tif (options?.address && !parsedSignature.publicKey.verifyAddress(options.address)) {\n\t\tthrow new Error(`Signature is not valid for the provided address`);\n\t}\n\n\treturn parsedSignature.publicKey;\n}\n\nfunction parseSignature(signature: string, options: { client?: ZkLoginCompatibleClient } = {}) {\n\tconst parsedSignature = parseSerializedSignature(signature);\n\n\tif (parsedSignature.signatureScheme === 'MultiSig') {\n\t\treturn {\n\t\t\t...parsedSignature,\n\t\t\tpublicKey: new MultiSigPublicKey(parsedSignature.multisig.multisig_pk),\n\t\t};\n\t}\n\n\tconst publicKey = publicKeyFromRawBytes(\n\t\tparsedSignature.signatureScheme,\n\t\tparsedSignature.publicKey,\n\t\toptions,\n\t);\n\treturn {\n\t\t...parsedSignature,\n\t\tpublicKey,\n\t};\n}\n\nexport function publicKeyFromRawBytes(\n\tsignatureScheme: SignatureScheme,\n\tbytes: Uint8Array,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n): PublicKey {\n\tlet publicKey: PublicKey;\n\tswitch (signatureScheme) {\n\t\tcase 'ED25519':\n\t\t\tpublicKey = new Ed25519PublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'Secp256k1':\n\t\t\tpublicKey = new Secp256k1PublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'Secp256r1':\n\t\t\tpublicKey = new Secp256r1PublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'MultiSig':\n\t\t\tpublicKey = new MultiSigPublicKey(bytes);\n\t\t\tbreak;\n\t\tcase 'ZkLogin':\n\t\t\tpublicKey = ZkLoginPublicIdentifier.fromBytes(bytes, options);\n\t\t\tbreak;\n\t\tcase 'Passkey':\n\t\t\tpublicKey = new PasskeyPublicKey(bytes);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported signature scheme ${signatureScheme}`);\n\t}\n\n\tif (options.address && publicKey.toSuiAddress() !== options.address) {\n\t\tthrow new Error(`Public key bytes do not match the provided address`);\n\t}\n\n\treturn publicKey;\n}\n\nexport function publicKeyFromSuiBytes(\n\tpublicKey: string | Uint8Array,\n\toptions: { client?: ZkLoginCompatibleClient; address?: string } = {},\n) {\n\tconst bytes = typeof publicKey === 'string' ? fromBase64(publicKey) : publicKey;\n\n\tconst signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0] as SignatureFlag];\n\n\treturn publicKeyFromRawBytes(signatureScheme, bytes.slice(1), options);\n}\n"],
  "mappings": "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",
  "names": ["import_publickey"]
}

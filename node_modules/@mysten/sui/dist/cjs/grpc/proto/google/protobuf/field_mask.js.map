{
  "version": 3,
  "sources": ["../../../../../../src/grpc/proto/google/protobuf/field_mask.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// @generated by protobuf-ts 2.9.6 with parameter force_server_none,optimize_code_size,ts_nocheck\n// @generated from protobuf file \"google/protobuf/field_mask.proto\" (package \"google.protobuf\", syntax proto3)\n// tslint:disable\n// @ts-nocheck\n//\n// Protocol Buffers - Google's data interchange format\n// Copyright 2008 Google Inc.  All rights reserved.\n// https://developers.google.com/protocol-buffers/\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\nimport { typeofJsonValue } from '@protobuf-ts/runtime';\nimport type { JsonValue } from '@protobuf-ts/runtime';\nimport { lowerCamelCase } from '@protobuf-ts/runtime';\nimport type { JsonReadOptions } from '@protobuf-ts/runtime';\nimport type { JsonWriteOptions } from '@protobuf-ts/runtime';\nimport { MessageType } from '@protobuf-ts/runtime';\n/**\n * `FieldMask` represents a set of symbolic field paths, for example:\n *\n *     paths: \"f.a\"\n *     paths: \"f.b.d\"\n *\n * Here `f` represents a field in some root message, `a` and `b`\n * fields in the message found in `f`, and `d` a field found in the\n * message in `f.b`.\n *\n * Field masks are used to specify a subset of fields that should be\n * returned by a get operation or modified by an update operation.\n * Field masks also have a custom JSON encoding (see below).\n *\n * # Field Masks in Projections\n *\n * When used in the context of a projection, a response message or\n * sub-message is filtered by the API to only contain those fields as\n * specified in the mask. For example, if the mask in the previous\n * example is applied to a response message as follows:\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *         x : 2\n *       }\n *       y : 13\n *     }\n *     z: 8\n *\n * The result will not contain specific values for fields x,y and z\n * (their value will be set to the default, and omitted in proto text\n * output):\n *\n *\n *     f {\n *       a : 22\n *       b {\n *         d : 1\n *       }\n *     }\n *\n * A repeated field is not allowed except at the last position of a\n * paths string.\n *\n * If a FieldMask object is not present in a get operation, the\n * operation applies to all fields (as if a FieldMask of all fields\n * had been specified).\n *\n * Note that a field mask does not necessarily apply to the\n * top-level response message. In case of a REST get operation, the\n * field mask applies directly to the response, but in case of a REST\n * list operation, the mask instead applies to each individual message\n * in the returned resource list. In case of a REST custom method,\n * other definitions may be used. Where the mask applies will be\n * clearly documented together with its declaration in the API.  In\n * any case, the effect on the returned resource/resources is required\n * behavior for APIs.\n *\n * # Field Masks in Update Operations\n *\n * A field mask in update operations specifies which fields of the\n * targeted resource are going to be updated. The API is required\n * to only change the values of the fields as specified in the mask\n * and leave the others untouched. If a resource is passed in to\n * describe the updated values, the API ignores the values of all\n * fields not covered by the mask.\n *\n * If a repeated field is specified for an update operation, new values will\n * be appended to the existing repeated field in the target resource. Note that\n * a repeated field is only allowed in the last position of a `paths` string.\n *\n * If a sub-message is specified in the last position of the field mask for an\n * update operation, then new value will be merged into the existing sub-message\n * in the target resource.\n *\n * For example, given the target message:\n *\n *     f {\n *       b {\n *         d: 1\n *         x: 2\n *       }\n *       c: [1]\n *     }\n *\n * And an update message:\n *\n *     f {\n *       b {\n *         d: 10\n *       }\n *       c: [2]\n *     }\n *\n * then if the field mask is:\n *\n *  paths: [\"f.b\", \"f.c\"]\n *\n * then the result will be:\n *\n *     f {\n *       b {\n *         d: 10\n *         x: 2\n *       }\n *       c: [1, 2]\n *     }\n *\n * An implementation may provide options to override this default behavior for\n * repeated and message fields.\n *\n * In order to reset a field's value to the default, the field must\n * be in the mask and set to the default value in the provided resource.\n * Hence, in order to reset all fields of a resource, provide a default\n * instance of the resource and set all fields in the mask, or do\n * not provide a mask as described below.\n *\n * If a field mask is not present on update, the operation applies to\n * all fields (as if a field mask of all fields has been specified).\n * Note that in the presence of schema evolution, this may mean that\n * fields the client does not know and has therefore not filled into\n * the request will be reset to their default. If this is unwanted\n * behavior, a specific service may require a client to always specify\n * a field mask, producing an error if not.\n *\n * As with get operations, the location of the resource which\n * describes the updated values in the request message depends on the\n * operation kind. In any case, the effect of the field mask is\n * required to be honored by the API.\n *\n * ## Considerations for HTTP REST\n *\n * The HTTP kind of an update operation which uses a field mask must\n * be set to PATCH instead of PUT in order to satisfy HTTP semantics\n * (PUT must only be used for full updates).\n *\n * # JSON Encoding of Field Masks\n *\n * In JSON, a field mask is encoded as a single string where paths are\n * separated by a comma. Fields name in each path are converted\n * to/from lower-camel naming conventions.\n *\n * As an example, consider the following message declarations:\n *\n *     message Profile {\n *       User user = 1;\n *       Photo photo = 2;\n *     }\n *     message User {\n *       string display_name = 1;\n *       string address = 2;\n *     }\n *\n * In proto a field mask for `Profile` may look as such:\n *\n *     mask {\n *       paths: \"user.display_name\"\n *       paths: \"photo\"\n *     }\n *\n * In JSON, the same mask is represented as below:\n *\n *     {\n *       mask: \"user.displayName,photo\"\n *     }\n *\n * # Field Masks and Oneof Fields\n *\n * Field masks treat fields in oneofs just as regular fields. Consider the\n * following message:\n *\n *     message SampleMessage {\n *       oneof test_oneof {\n *         string name = 4;\n *         SubMessage sub_message = 9;\n *       }\n *     }\n *\n * The field mask can be:\n *\n *     mask {\n *       paths: \"name\"\n *     }\n *\n * Or:\n *\n *     mask {\n *       paths: \"sub_message\"\n *     }\n *\n * Note that oneof type names (\"test_oneof\" in this case) cannot be used in\n * paths.\n *\n * ## Field Mask Verification\n *\n * The implementation of any API method which has a FieldMask type field in the\n * request should verify the included field paths, and return an\n * `INVALID_ARGUMENT` error if any path is unmappable.\n *\n * @generated from protobuf message google.protobuf.FieldMask\n */\nexport interface FieldMask {\n\t/**\n\t * The set of field mask paths.\n\t *\n\t * @generated from protobuf field: repeated string paths = 1;\n\t */\n\tpaths: string[];\n}\n// @generated message type with reflection information, may provide speed optimized methods\nclass FieldMask$Type extends MessageType<FieldMask> {\n\tconstructor() {\n\t\tsuper('google.protobuf.FieldMask', [\n\t\t\t{\n\t\t\t\tno: 1,\n\t\t\t\tname: 'paths',\n\t\t\t\tkind: 'scalar',\n\t\t\t\trepeat: 2 /*RepeatType.UNPACKED*/,\n\t\t\t\tT: 9 /*ScalarType.STRING*/,\n\t\t\t},\n\t\t]);\n\t}\n\t/**\n\t * Encode `FieldMask` to JSON object.\n\t */\n\tinternalJsonWrite(message: FieldMask, options: JsonWriteOptions): JsonValue {\n\t\tconst invalidFieldMaskJsonRegex = /[A-Z]|(_([.0-9_]|$))/g;\n\t\treturn message.paths\n\t\t\t.map((p) => {\n\t\t\t\tif (invalidFieldMaskJsonRegex.test(p))\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Unable to encode FieldMask to JSON. lowerCamelCase of path name \"' +\n\t\t\t\t\t\t\tp +\n\t\t\t\t\t\t\t'\" is irreversible.',\n\t\t\t\t\t);\n\t\t\t\treturn lowerCamelCase(p);\n\t\t\t})\n\t\t\t.join(',');\n\t}\n\t/**\n\t * Decode `FieldMask` from JSON object.\n\t */\n\tinternalJsonRead(json: JsonValue, options: JsonReadOptions, target?: FieldMask): FieldMask {\n\t\tif (typeof json !== 'string')\n\t\t\tthrow new Error(\n\t\t\t\t'Unable to parse FieldMask from JSON ' + typeofJsonValue(json) + '. Expected string.',\n\t\t\t);\n\t\tif (!target) target = this.create();\n\t\tif (json === '') return target;\n\t\tlet camelToSnake = (str: string) => {\n\t\t\tif (str.includes('_'))\n\t\t\t\tthrow new Error('Unable to parse FieldMask from JSON. Path names must be lowerCamelCase.');\n\t\t\tlet sc = str.replace(/[A-Z]/g, (letter) => '_' + letter.toLowerCase());\n\t\t\treturn sc;\n\t\t};\n\t\ttarget.paths = json.split(',').map(camelToSnake);\n\t\treturn target;\n\t}\n}\n/**\n * @generated MessageType for protobuf message google.protobuf.FieldMask\n */\nexport const FieldMask = new FieldMask$Type();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAsCA,qBAAgC;AAEhC,IAAAA,kBAA+B;AAG/B,IAAAA,kBAA4B;AAqN5B,MAAM,uBAAuB,4BAAuB;AAAA,EACnD,cAAc;AACb,UAAM,6BAA6B;AAAA,MAClC;AAAA,QACC,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,GAAG;AAAA,MACJ;AAAA,IACD,CAAC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkB,SAAoB,SAAsC;AAC3E,UAAM,4BAA4B;AAClC,WAAO,QAAQ,MACb,IAAI,CAAC,MAAM;AACX,UAAI,0BAA0B,KAAK,CAAC;AACnC,cAAM,IAAI;AAAA,UACT,sEACC,IACA;AAAA,QACF;AACD,iBAAO,gCAAe,CAAC;AAAA,IACxB,CAAC,EACA,KAAK,GAAG;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,iBAAiB,MAAiB,SAA0B,QAA+B;AAC1F,QAAI,OAAO,SAAS;AACnB,YAAM,IAAI;AAAA,QACT,6CAAyC,gCAAgB,IAAI,IAAI;AAAA,MAClE;AACD,QAAI,CAAC,OAAQ,UAAS,KAAK,OAAO;AAClC,QAAI,SAAS,GAAI,QAAO;AACxB,QAAI,eAAe,CAAC,QAAgB;AACnC,UAAI,IAAI,SAAS,GAAG;AACnB,cAAM,IAAI,MAAM,yEAAyE;AAC1F,UAAI,KAAK,IAAI,QAAQ,UAAU,CAAC,WAAW,MAAM,OAAO,YAAY,CAAC;AACrE,aAAO;AAAA,IACR;AACA,WAAO,QAAQ,KAAK,MAAM,GAAG,EAAE,IAAI,YAAY;AAC/C,WAAO;AAAA,EACR;AACD;AAIO,MAAM,YAAY,IAAI,eAAe;",
  "names": ["import_runtime"]
}

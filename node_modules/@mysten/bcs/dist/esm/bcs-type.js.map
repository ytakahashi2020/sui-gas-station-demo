{
  "version": 3,
  "sources": ["../../src/bcs-type.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, fromBase64, toBase58, toBase64, fromHex, toHex } from '@mysten/utils';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\nimport type { EnumInputShape, EnumOutputShape, JoinString } from './types.js';\n\nexport interface BcsTypeOptions<T, Input = T, Name extends string = string> {\n\tname?: Name;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T, const Name extends string = string> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: Name;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input, Name>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input, NewName extends string = Name>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2, NewName>) {\n\t\treturn new BcsType<T2, Input2, NewName>({\n\t\t\tname: (name ?? this.name) as NewName,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array<ArrayBuffer>;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(schema: BcsType<T, Input>, bytes: Uint8Array<ArrayBuffer>) {\n\t\tthis.#schema = schema;\n\t\tthis.#bytes = bytes;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T, const Name extends string = string>({\n\tsize,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input, Name>) {\n\treturn new BcsType<T, Input, Name>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number, Name>) {\n\treturn fixedSizeBcsType<number, number, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType<const Name extends string = string>({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: Name;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint, Name>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T, const Name extends string = string>({\n\tserialize,\n\t...options\n}: {\n\tname: Name;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array<ArrayBuffer>;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType<const Name extends string = string>({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: Name;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string, string, Name>) {\n\treturn new BcsType<string, string, Name>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n\nexport interface BcsStructOptions<\n\tT extends Record<string, BcsType<any>>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsStruct<\n\tT extends Record<string, BcsType<any>>,\n\tconst Name extends string = string,\n> extends BcsType<\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t},\n\tName\n> {\n\tconstructor({ name, fields, ...options }: BcsStructOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\tsuper({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsEnumOptions<\n\tT extends Record<string, BcsType<any> | null>,\n\tName extends string = string,\n> extends Omit<\n\t\tBcsTypeOptions<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t\t\t}>,\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname: Name;\n\tfields: T;\n}\n\nexport class BcsEnum<\n\tT extends Record<string, BcsType<any> | null>,\n\tconst Name extends string = string,\n> extends BcsType<\n\tEnumOutputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t}>,\n\tEnumInputShape<{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer U, any> ? U : boolean | object | null;\n\t}>,\n\tName\n> {\n\tconstructor({ fields, ...options }: BcsEnumOptions<T, Name>) {\n\t\tconst canonicalOrder = Object.entries(fields as object);\n\t\tsuper({\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${options.name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(fields, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(fields, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${options.name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(fields, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n\nexport interface BcsTupleOptions<T extends readonly BcsType<any>[], Name extends string>\n\textends Omit<\n\t\tBcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t},\n\t\t\tName\n\t\t>,\n\t\t'name'\n\t> {\n\tname?: Name;\n\tfields: T;\n}\n\nexport class BcsTuple<\n\tconst T extends readonly BcsType<any>[],\n\tconst Name extends\n\t\tstring = `(${JoinString<{ [K in keyof T]: T[K] extends BcsType<any, any, infer T> ? T : never }, ', '>})`,\n> extends BcsType<\n\t{\n\t\t-readonly [K in keyof T]: T[K] extends BcsType<infer T, any> ? T : never;\n\t},\n\t{\n\t\t[K in keyof T]: T[K] extends BcsType<any, infer T> ? T : never;\n\t},\n\tName\n> {\n\tconstructor({ fields, name, ...options }: BcsTupleOptions<T, Name>) {\n\t\tsuper({\n\t\t\tname: name ?? (`(${fields.map((t) => t.name).join(', ')})` as never),\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tconst size = fields[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const field of fields) {\n\t\t\t\t\tresult.push(field.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < fields.length; i++) {\n\t\t\t\t\tfields[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== fields.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${fields.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": ["options", "name"]
}

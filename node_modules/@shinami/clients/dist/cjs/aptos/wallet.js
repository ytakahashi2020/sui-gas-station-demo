"use strict";
/**
 * Copyright 2023-2024 Shinami Corp.
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShinamiWalletSigner = exports.KeySession = exports.WalletClient = exports.KeyClient = void 0;
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const superstruct_1 = require("superstruct");
const rpc_js_1 = require("../rpc.js");
const client_js_1 = require("@open-rpc/client-js");
const endpoints_js_1 = require("./endpoints.js");
const region_js_1 = require("../region.js");
/**
 * Shinami Key RPC client for Aptos.
 */
class KeyClient extends rpc_js_1.ShinamiRpcClient {
    /**
     * @param accessKey Aptos Wallet access key.
     * @param url Optional URL override.
     */
    constructor(accessKey, url = (0, region_js_1.inferRegionalValueFromAccessKey)(accessKey, endpoints_js_1.KeyRpcUrls, (keyRpcUrls) => keyRpcUrls.us1)) {
        super(accessKey, url);
    }
    /**
     * Creates a session with the provided wallet secret.
     * @param secret Wallet secret. For later operations to succeed, the secret must match what the
     *    wallet was created with.
     * @returns A session token used to perform sensitive wallet operations with, valid for 10 mins.
     */
    createSession(secret) {
        return this.request("key_createSession", [secret], (0, superstruct_1.string)());
    }
}
exports.KeyClient = KeyClient;
/**
 * Results for wallet operation methods.
 */
const WalletResult = (0, superstruct_1.object)({
    accountAddress: (0, superstruct_1.string)(),
});
/**
 * Result of signing a transaction
 */
const SignTransactionResult = (0, superstruct_1.object)({
    signature: (0, superstruct_1.array)((0, superstruct_1.integer)()),
});
/**
 * Gasless transaction execution result
 */
const ExecuteGaslessTransactionResult = (0, superstruct_1.object)({
    pendingTransaction: (0, superstruct_1.unknown)(),
});
/**
 * Shinami Wallet RPC client for Aptos.
 */
class WalletClient extends rpc_js_1.ShinamiRpcClient {
    /**
     * @param accessKey Aptos Wallet access key.
     * @param url Optional URL override.
     */
    constructor(accessKey, url = (0, region_js_1.inferRegionalValueFromAccessKey)(accessKey, endpoints_js_1.WalletRpcUrls, (walletRpcUrls) => walletRpcUrls.us1)) {
        super(accessKey, url);
    }
    /**
     * Creates a new wallet that is not initialized on chain.
     * @param walletId Wallet id. Must not have been previously used, or an error will be returned.
     * @param sessionToken Session token. Obtained by `KeyClient.createSession`.
     * @returns Aptos address of the created wallet.
     */
    createWallet(walletId, sessionToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const { accountAddress } = yield this.request("wal_createWallet", [walletId, sessionToken], WalletResult);
            return ts_sdk_1.AccountAddress.from(accountAddress);
        });
    }
    /**
     * Initializes a wallet that was created with `createWallet` onto the Aptos chain. Network is dictated by the access key used.
     * @param walletId Wallet id used previously in `createWallet`
     * @param sessionToken Session token. Obtained by `KeyClient.createSession`.
     * @returns Aptos address of the created wallet that is now initialized on chain.
     */
    initializeWalletOnChain(walletId, sessionToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const { accountAddress } = yield this.request("wal_initializeWalletOnChain", [walletId, sessionToken], WalletResult);
            return ts_sdk_1.AccountAddress.from(accountAddress);
        });
    }
    /**
     * Creates a new wallet and initializes it on the Aptos chain. Network is dictated by the access key used.
     * @param walletId Wallet id. Must not have been previously used, or an error will be returned.
     * @param sessionToken Session token. Obtained by `KeyClient.createSession`.
     * @returns Aptos address of the created wallet that is also initialized on chain.
     */
    createWalletOnChain(walletId, sessionToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const { accountAddress } = yield this.request("wal_createWalletOnChain", [walletId, sessionToken], WalletResult);
            return ts_sdk_1.AccountAddress.from(accountAddress);
        });
    }
    /**
     * Retrieves a wallet address.
     * @param walletId Wallet id. Does not have to be an initialized address.
     * @returns Wallet address
     */
    getWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { accountAddress } = yield this.request("wal_getWallet", [walletId], WalletResult);
            return ts_sdk_1.AccountAddress.from(accountAddress);
        });
    }
    /**
     * Signs a transaction with the specified wallet.
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param transaction Transaction. Can be SimpleTransaction or MultiAgentTransaction
     * @returns Signing Result
     */
    signTransaction(walletId, sessionToken, transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const { signature } = yield this.request("wal_signTransaction", (0, rpc_js_1.trimTrailingParams)([
                walletId,
                sessionToken,
                transaction.rawTransaction.bcsToHex().toString(),
                (_b = (_a = transaction.secondarySignerAddresses) === null || _a === void 0 ? void 0 : _a.map((x) => x.toString())) !== null && _b !== void 0 ? _b : [],
                (_c = transaction.feePayerAddress) === null || _c === void 0 ? void 0 : _c.toString(),
            ]), SignTransactionResult);
            return ts_sdk_1.AccountAuthenticator.deserialize(new ts_sdk_1.Deserializer(new Uint8Array(signature)));
        });
    }
    executeGaslessTransaction(walletId, sessionToken, transaction, secondarySignatures) {
        return __awaiter(this, void 0, void 0, function* () {
            const secondarySigners = [];
            if (transaction.secondarySignerAddresses) {
                if ((secondarySignatures === null || secondarySignatures === void 0 ? void 0 : secondarySignatures.length) !==
                    transaction.secondarySignerAddresses.length)
                    throw new Error("Unexpected number of secondary signatures");
                secondarySigners.push(...transaction.secondarySignerAddresses.map((address, i) => ({
                    address: address.toString(),
                    signature: secondarySignatures[i].bcsToHex().toString(),
                })));
            }
            const { pendingTransaction } = yield this.request("wal_executeGaslessTransaction", [
                walletId,
                sessionToken,
                transaction.rawTransaction.bcsToHex().toString(),
                secondarySigners,
            ], ExecuteGaslessTransactionResult);
            return pendingTransaction;
        });
    }
}
exports.WalletClient = WalletClient;
/**
 * A secret session with Shinami Aptos key service.
 */
class KeySession {
    constructor(secret, keyClient) {
        this.secret = secret;
        this.keyClient = keyClient;
    }
    /**
     * Refreshes the session token.
     * @returns The refreshed session token.
     */
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            this.token = yield this.keyClient.createSession(this.secret);
            return this.token;
        });
    }
    /**
     * Runs a code block with the session token. Handles token refreshes upon expiration.
     * @param run The code to run.
     * @returns Result of `run`.
     */
    withToken(run) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.token) {
                return yield run(yield this.refreshToken());
            }
            else {
                try {
                    return yield run(this.token);
                }
                catch (e) {
                    if (e instanceof client_js_1.JSONRPCError && e.code === -32602) {
                        const details = (0, rpc_js_1.errorDetails)(e);
                        if ((_a = details === null || details === void 0 ? void 0 : details.details) === null || _a === void 0 ? void 0 : _a.includes("Bad session token")) {
                            return yield run(yield this.refreshToken());
                        }
                    }
                    throw e;
                }
            }
        });
    }
}
exports.KeySession = KeySession;
/**
 * A signer based on Shinami's invisible wallet for Aptos.
 *
 * It transparently manages session token refreshes.
 */
class ShinamiWalletSigner {
    constructor(walletId, walletClient, secretOrSession, keyClient) {
        this.isInitialized = false;
        this.walletId = walletId;
        this.walletClient = walletClient;
        if (secretOrSession instanceof KeySession) {
            this.session = secretOrSession;
        }
        else {
            if (!keyClient)
                throw new Error("Must provide keyClient with secret");
            this.session = new KeySession(secretOrSession, keyClient);
        }
    }
    /**
     * Retrieves the wallet address if created in Shinami.
     * @param autoCreate Whether to automatically create the wallet (off chain) if it doesn't exist yet in Shinami.
     *    If `false`, and the wallet doesn't exist, an error will be thrown.
     * @param onChain whether to initialize the address on chain. It will use the network attached to the access
     *    key in the sessionToken.
     * @returns Wallet address.
     */
    getAddress() {
        return __awaiter(this, arguments, void 0, function* (autoCreate = false, onChain = false) {
            if (!this.address) {
                // wallet has not yet been created or initialized
                this.address = yield this._getAddress(autoCreate, onChain);
            }
            else if (!this.isInitialized && onChain) {
                // it is created in Shinami but not on chain, and onChain param is set
                yield this.tryInitializeOnChain();
                this.isInitialized = true;
            }
            return this.address;
        });
    }
    _getAddress(autoCreate, onChain) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.walletClient.getWallet(this.walletId);
            }
            catch (e) {
                if (e instanceof client_js_1.JSONRPCError && e.code === -32602 && autoCreate) {
                    const address = yield this.tryCreate(onChain);
                    if (address)
                        return address;
                    return yield this.walletClient.getWallet(this.walletId);
                }
                throw e;
            }
        });
    }
    /**
     * Tries to initialize this wallet on chain.
     * @returns The wallet address that was successfully initialized on chain. `undefined` if this
     *  wallet already exists on chain. An error will be thrown if wallet has not been created on
     *  Shinami yet.
     */
    tryInitializeOnChain() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.session.withToken((token) => this.walletClient.initializeWalletOnChain(this.walletId, token));
            }
            catch (e) {
                if (e instanceof client_js_1.JSONRPCError && e.code === -32013)
                    return;
                throw e;
            }
        });
    }
    /**
     * Tries to create this wallet if it doesn't exist.
     * @param onChain If set, it will try to create the wallet and initialize it on chain as well.
     *    The access key used must be authorized for Aptos gas station. On chain initialization costs
     *    will be drawn from the attached gas station fund.
     * @returns The wallet address if it was just created. `undefined` if pre-existing, in which case
     *  you can call `getAddfress` to retrieve the said info.
     */
    tryCreate(onChain) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                return yield this.session.withToken((token) => onChain
                    ? this.walletClient.createWalletOnChain(this.walletId, token)
                    : this.walletClient.createWallet(this.walletId, token));
            }
            catch (e) {
                if (e instanceof client_js_1.JSONRPCError && e.code === -32602) {
                    const details = (0, rpc_js_1.errorDetails)(e);
                    if ((_a = details === null || details === void 0 ? void 0 : details.details) === null || _a === void 0 ? void 0 : _a.includes("Wallet ID already exists"))
                        return;
                }
                throw e;
            }
        });
    }
    /**
     * Signs a transaction with this wallet.
     * @param transaction Transaction of type SimpleTransaction or MultiAgentTransaction.
     * @returns Signing result.
     */
    signTransaction(transaction) {
        return this.session.withToken((token) => this.walletClient.signTransaction(this.walletId, token, transaction));
    }
    executeGaslessTransaction(transaction, secondarySignatures) {
        if (secondarySignatures !== undefined) {
            return this.session.withToken((token) => this.walletClient.executeGaslessTransaction(this.walletId, token, transaction, secondarySignatures));
        }
        else {
            return this.session.withToken((token) => this.walletClient.executeGaslessTransaction(this.walletId, token, transaction));
        }
    }
}
exports.ShinamiWalletSigner = ShinamiWalletSigner;

/**
 * Copyright 2023-2024 Shinami Corp.
 * SPDX-License-Identifier: Apache-2.0
 */
import { AccountAddress, SimpleTransaction, MultiAgentTransaction, AnyRawTransaction, AccountAuthenticator, PendingTransactionResponse } from "@aptos-labs/ts-sdk";
import { ShinamiRpcClient } from "../rpc.js";
/**
 * Shinami Key RPC client for Aptos.
 */
export declare class KeyClient extends ShinamiRpcClient {
    /**
     * @param accessKey Aptos Wallet access key.
     * @param url Optional URL override.
     */
    constructor(accessKey: string, url?: string);
    /**
     * Creates a session with the provided wallet secret.
     * @param secret Wallet secret. For later operations to succeed, the secret must match what the
     *    wallet was created with.
     * @returns A session token used to perform sensitive wallet operations with, valid for 10 mins.
     */
    createSession(secret: string): Promise<string>;
}
/**
 * Shinami Wallet RPC client for Aptos.
 */
export declare class WalletClient extends ShinamiRpcClient {
    /**
     * @param accessKey Aptos Wallet access key.
     * @param url Optional URL override.
     */
    constructor(accessKey: string, url?: string);
    /**
     * Creates a new wallet that is not initialized on chain.
     * @param walletId Wallet id. Must not have been previously used, or an error will be returned.
     * @param sessionToken Session token. Obtained by `KeyClient.createSession`.
     * @returns Aptos address of the created wallet.
     */
    createWallet(walletId: string, sessionToken: string): Promise<AccountAddress>;
    /**
     * Initializes a wallet that was created with `createWallet` onto the Aptos chain. Network is dictated by the access key used.
     * @param walletId Wallet id used previously in `createWallet`
     * @param sessionToken Session token. Obtained by `KeyClient.createSession`.
     * @returns Aptos address of the created wallet that is now initialized on chain.
     */
    initializeWalletOnChain(walletId: string, sessionToken: string): Promise<AccountAddress>;
    /**
     * Creates a new wallet and initializes it on the Aptos chain. Network is dictated by the access key used.
     * @param walletId Wallet id. Must not have been previously used, or an error will be returned.
     * @param sessionToken Session token. Obtained by `KeyClient.createSession`.
     * @returns Aptos address of the created wallet that is also initialized on chain.
     */
    createWalletOnChain(walletId: string, sessionToken: string): Promise<AccountAddress>;
    /**
     * Retrieves a wallet address.
     * @param walletId Wallet id. Does not have to be an initialized address.
     * @returns Wallet address
     */
    getWallet(walletId: string): Promise<AccountAddress>;
    /**
     * Signs a transaction with the specified wallet.
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param transaction Transaction. Can be SimpleTransaction or MultiAgentTransaction
     * @returns Signing Result
     */
    signTransaction(walletId: string, sessionToken: string, transaction: AnyRawTransaction): Promise<AccountAuthenticator>;
    /**
     * Sponsors, signs, and executes a SimpleTransaction gaslessly with the specified wallet as the sender.
     * To call this method, your access key must be authorized for both the Aptos Wallet Service and Aptos Gas Station.
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param transaction Transaction of type SimpleTransaction.
     * @returns The submitted transaction in mempool
     */
    executeGaslessTransaction(walletId: string, sessionToken: string, transaction: SimpleTransaction): Promise<PendingTransactionResponse>;
    /**
     * Executes a MultiAgentTransaction gaslessly with the specified wallet as the sender.
     * To call this method, your access key must be authorized for both the Aptos Wallet Service and Aptos Gas Station.
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param transaction Transaction of type MultiAgentTransaction.
     * @param secondarySignatures Other signers for this MultiAgentTransaction.
     * @returns The submitted transaction in mempool
     */
    executeGaslessTransaction(walletId: string, sessionToken: string, transaction: MultiAgentTransaction, secondarySignatures: AccountAuthenticator[]): Promise<PendingTransactionResponse>;
}
/**
 * A secret session with Shinami Aptos key service.
 */
export declare class KeySession {
    private readonly secret;
    readonly keyClient: KeyClient;
    private token?;
    constructor(secret: string, keyClient: KeyClient);
    /**
     * Refreshes the session token.
     * @returns The refreshed session token.
     */
    refreshToken(): Promise<string>;
    /**
     * Runs a code block with the session token. Handles token refreshes upon expiration.
     * @param run The code to run.
     * @returns Result of `run`.
     */
    withToken<T>(run: (token: string) => Promise<T>): Promise<T>;
}
/**
 * A signer based on Shinami's invisible wallet for Aptos.
 *
 * It transparently manages session token refreshes.
 */
export declare class ShinamiWalletSigner {
    readonly walletId: string;
    readonly walletClient: WalletClient;
    private readonly session;
    private address?;
    private isInitialized;
    constructor(walletId: string, walletClient: WalletClient, session: KeySession);
    constructor(walletId: string, walletClient: WalletClient, secret: string, keyClient: KeyClient);
    /**
     * Retrieves the wallet address if created in Shinami.
     * @param autoCreate Whether to automatically create the wallet (off chain) if it doesn't exist yet in Shinami.
     *    If `false`, and the wallet doesn't exist, an error will be thrown.
     * @param onChain whether to initialize the address on chain. It will use the network attached to the access
     *    key in the sessionToken.
     * @returns Wallet address.
     */
    getAddress(autoCreate?: boolean, onChain?: boolean): Promise<AccountAddress>;
    private _getAddress;
    /**
     * Tries to initialize this wallet on chain.
     * @returns The wallet address that was successfully initialized on chain. `undefined` if this
     *  wallet already exists on chain. An error will be thrown if wallet has not been created on
     *  Shinami yet.
     */
    tryInitializeOnChain(): Promise<AccountAddress | undefined>;
    /**
     * Tries to create this wallet if it doesn't exist.
     * @param onChain If set, it will try to create the wallet and initialize it on chain as well.
     *    The access key used must be authorized for Aptos gas station. On chain initialization costs
     *    will be drawn from the attached gas station fund.
     * @returns The wallet address if it was just created. `undefined` if pre-existing, in which case
     *  you can call `getAddfress` to retrieve the said info.
     */
    tryCreate(onChain: boolean): Promise<AccountAddress | undefined>;
    /**
     * Signs a transaction with this wallet.
     * @param transaction Transaction of type SimpleTransaction or MultiAgentTransaction.
     * @returns Signing result.
     */
    signTransaction(transaction: AnyRawTransaction): Promise<AccountAuthenticator>;
    /**
     * Sponsors, signs, and executes a SimpleTransaction gaslessly with the specified wallet as the sender.
     * To call this method, your access key must be authorized for both the Aptos Wallet Service and Aptos Gas Station.
     * @param transaction Transaction of type SimpleTransaction.
     * @returns The submitted transaction in mempool.
     */
    executeGaslessTransaction(transaction: SimpleTransaction): Promise<PendingTransactionResponse>;
    /**
     * Sponsors, signs, and executes a MultiAgentTransaction gaslessly with the specified wallet as the sender.
     * To call this method, your access key must be authorized for both the Aptos Wallet Service and Aptos Gas Station.
     * @param transaction Transaction of type MultiAgentTransaction.
     * @param secondarySignatures: Other signers for this MultiAgentTransaction.
     * @returns The submitted transaction in mempool.
     */
    executeGaslessTransaction(transaction: MultiAgentTransaction, secondarySignatures: AccountAuthenticator[]): Promise<PendingTransactionResponse>;
}

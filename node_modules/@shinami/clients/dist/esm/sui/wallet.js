/**
 * Copyright 2023-2024 Shinami Corp.
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { toB64 } from "@mysten/sui/utils";
import { JSONRPCError } from "@open-rpc/client-js";
import { nullable, object, string } from "superstruct";
import { ShinamiRpcClient, errorDetails, trimTrailingParams } from "../rpc.js";
import { KeyRpcUrls, WalletRpcUrls } from "./endpoints.js";
import { inferRegionalValueFromAccessKey } from "../region.js";
/**
 * Shinami Key RPC client.
 */
export class KeyClient extends ShinamiRpcClient {
    /**
     * @param accessKey Wallet access key.
     * @param url Optional URL override.
     */
    constructor(accessKey, url = inferRegionalValueFromAccessKey(accessKey, KeyRpcUrls, (keyRpcUrls) => keyRpcUrls.us1)) {
        super(accessKey, url);
    }
    /**
     * Creates a session with the provided wallet secret.
     * @param secret Wallet secret. For later operations to succeed, the secret must match what the
     *    wallet was created with.
     * @returns A session token used to perform sensitive wallet operations with, valid for 10 mins.
     */
    createSession(secret) {
        return this.request("shinami_key_createSession", [secret], string());
    }
}
/**
 * Transaction signing result.
 */
export const SignTransactionResult = object({
    signature: string(),
    txDigest: string(),
});
/**
 * Shinami Wallet RPC client.
 */
export class WalletClient extends ShinamiRpcClient {
    /**
     * @param accessKey Wallet access key.
     * @param url Optional URL override.
     */
    constructor(accessKey, url = inferRegionalValueFromAccessKey(accessKey, WalletRpcUrls, (walletRpcUrls) => walletRpcUrls.us1)) {
        super(accessKey, url);
    }
    /**
     * Creates a new wallet.
     * @param walletId Wallet id. Must not exist, or an error will be returned.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @returns Sui address of the created wallet.
     */
    createWallet(walletId, sessionToken) {
        return this.request("shinami_wal_createWallet", [walletId, sessionToken], string());
    }
    /**
     * Retrieves the wallet address.
     * @param walletId Wallet id.
     * @returns Wallet address.
     */
    getWallet(walletId) {
        return this.request("shinami_wal_getWallet", [walletId], string());
    }
    /**
     * Signs a transaction with the specified wallet.
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param txBytes Transaction bytes. If `string`, assumed to be Base64 encoded.
     * @returns Signing result.
     */
    signTransaction(walletId, sessionToken, txBytes) {
        if (txBytes instanceof Uint8Array)
            txBytes = toB64(txBytes);
        return this.request("shinami_wal_signTransactionBlock", [walletId, sessionToken, txBytes], SignTransactionResult);
    }
    /**
     * Signs a personal message with the specified wallet.
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param message Personal message bytes. If `string`, assumed to be Base64 encoded.
     * @param wrapBcs If true, wrap the message bytes in a BCS struct before signing.
     * @returns Base64 encoded serialized signature.
     */
    signPersonalMessage(walletId, sessionToken, message, wrapBcs = true) {
        if (message instanceof Uint8Array)
            message = toB64(message);
        return this.request("shinami_wal_signPersonalMessage", [walletId, sessionToken, message, wrapBcs], string());
    }
    /**
     * Sponsors, signs, and executes a gasless transaction.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Gas Station
     * - Node Service
     *
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param tx Gasless transaction.
     * @param options Transaction execution response options.
     * @param requestType Transaction execution request type.
     * @returns Transaction execution response.
     */
    executeGaslessTransaction(walletId, sessionToken, tx, options, requestType) {
        return this.request("shinami_wal_executeGaslessTransactionBlock", trimTrailingParams([
            walletId,
            sessionToken,
            tx.txKind,
            tx.gasBudget,
            options,
            requestType,
            tx.gasPrice,
        ]));
    }
    /**
     * [Beneficiary Graph API]
     * Designates a beneficiary account for this wallet in the specified beneficiary graph instance.
     * Calling this method multiple times will override the previous designations.
     *
     * Apps participating in Bullshark Quests can use this method to link up Shinami invisible wallets
     * with their users' self-custody wallets.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Gas Station
     * - Node Service
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param beneficiaryGraphId Id of the beneficiary graph instance.
     * @param beneficiaryAddress Beneficiary address.
     * @returns Transaction digest for this operation.
     */
    setBeneficiary(walletId, sessionToken, beneficiaryGraphId, beneficiaryAddress) {
        return this.request("shinami_walx_setBeneficiary", [walletId, sessionToken, beneficiaryGraphId, beneficiaryAddress], string());
    }
    /**
     * [Beneficiary Graph API]
     * Clears any beneficiary designation for this wallet in the specified beneficiary graph instance.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Gas Station
     * - Node Service
     * @param walletId Wallet id.
     * @param sessionToken Session token, obtained by `KeyClient.createSession`.
     * @param beneficiaryGraphId Id of the beneficiary graph instance.
     * @returns Transaction digest for this operation.
     */
    unsetBeneficiary(walletId, sessionToken, beneficiaryGraphId) {
        return this.request("shinami_walx_unsetBeneficiary", [walletId, sessionToken, beneficiaryGraphId], string());
    }
    /**
     * [Beneficiary Graph API]
     * Gets the beneficiary designation for this wallet in the specified beneficiary graph instance.
     * This is a convenience method on top of suix_getDynamicFieldObject.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Node Service
     * @param walletId Wallet id.
     * @param beneficiaryGraphId Id of the beneficiary graph instance.
     * @returns Beneficiary address, or null if no beneficiary is designated.
     */
    getBeneficiary(walletId, beneficiaryGraphId) {
        return this.request("shinami_walx_getBeneficiary", [walletId, beneficiaryGraphId], nullable(string()));
    }
}
/**
 * A secret session with Shinami key service.
 */
export class KeySession {
    constructor(secret, keyClient) {
        this.secret = secret;
        this.keyClient = keyClient;
    }
    /**
     * Refreshes the session token.
     * @returns The refreshed session token.
     */
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            this.token = yield this.keyClient.createSession(this.secret);
            return this.token;
        });
    }
    /**
     * Runs a code block with the session token. Handles token refreshes upon expiration.
     * @param run The code to run.
     * @returns Result of `run`.
     */
    withToken(run) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.token) {
                return yield run(yield this.refreshToken());
            }
            else {
                try {
                    return yield run(this.token);
                }
                catch (e) {
                    if (e instanceof JSONRPCError && e.code === -32602) {
                        const details = errorDetails(e);
                        if ((_a = details === null || details === void 0 ? void 0 : details.details) === null || _a === void 0 ? void 0 : _a.includes("Bad session token")) {
                            return yield run(yield this.refreshToken());
                        }
                    }
                    throw e;
                }
            }
        });
    }
}
/**
 * A signer based on Shinami's invisible wallet.
 *
 * It transparently manages session token refreshes.
 */
export class ShinamiWalletSigner {
    constructor(walletId, walletClient, secretOrSession, keyClient) {
        this.walletId = walletId;
        this.walletClient = walletClient;
        if (secretOrSession instanceof KeySession) {
            this.session = secretOrSession;
        }
        else {
            if (!keyClient)
                throw new Error("Must provide keyClient with secret");
            this.session = new KeySession(secretOrSession, keyClient);
        }
    }
    /**
     * Retrieves the wallet address.
     * @param autoCreate Whether to automatically create the wallet if it doesn't exist yet.
     *    If `false`, and the wallet doesn't exist, an error will be thrown.
     * @returns Wallet address.
     */
    getAddress() {
        return __awaiter(this, arguments, void 0, function* (autoCreate = false) {
            if (!this.address)
                this.address = yield this._getAddress(autoCreate);
            return this.address;
        });
    }
    _getAddress(autoCreate) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.walletClient.getWallet(this.walletId);
            }
            catch (e) {
                if (autoCreate && e instanceof JSONRPCError && e.code === -32602) {
                    const address = yield this.tryCreate();
                    if (address)
                        return address;
                    return yield this.walletClient.getWallet(this.walletId);
                }
                throw e;
            }
        });
    }
    /**
     * Tries to create this wallet if not exists.
     * @returns The wallet address if it was just created. `undefined` if pre-existing, in which case
     *    you can call `getAddress` to retrive the said info.
     */
    tryCreate() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                return yield this.session.withToken((token) => this.walletClient.createWallet(this.walletId, token));
            }
            catch (e) {
                if (e instanceof JSONRPCError && e.code === -32602) {
                    const details = errorDetails(e);
                    if ((_a = details === null || details === void 0 ? void 0 : details.details) === null || _a === void 0 ? void 0 : _a.includes("Wallet ID already exists"))
                        return;
                }
                throw e;
            }
        });
    }
    /**
     * Signs a transaction with this wallet.
     * @param txBytes Transaction bytes. If `string`, assumed to be Base64 encoded.
     * @returns Signing result.
     */
    signTransaction(txBytes) {
        return this.session.withToken((token) => this.walletClient.signTransaction(this.walletId, token, txBytes));
    }
    /**
     * Signs a personal message with this wallet.
     * @param message Personal message bytes. If `string`, assumed to be Base64 encoded.
     * @param wrapBcs If true, wrap the message bytes in a BCS struct before signing.
     * @returns Base64 encoded serialized signature.
     */
    signPersonalMessage(message, wrapBcs = true) {
        return this.session.withToken((token) => this.walletClient.signPersonalMessage(this.walletId, token, message, wrapBcs));
    }
    /**
     * Sponsors, signs, and executes a gasless transaction.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Gas Station
     * - Node Service
     *
     * @param tx Gasless transaction.
     * @param options Transaction execution response options.
     * @param requestType Transaction execution request type.
     * @returns Transaction execution response.
     */
    executeGaslessTransaction(tx, options, requestType) {
        return this.session.withToken((token) => this.walletClient.executeGaslessTransaction(this.walletId, token, tx, options, requestType));
    }
    /**
     * [Beneficiary Graph API]
     * Designates a beneficiary account for this wallet in the specified beneficiary graph instance.
     * Calling this method multiple times will override the previous designations.
     *
     * Apps participating in Bullshark Quests can use this method to link up Shinami invisible wallets
     * with their users' self-custody wallets.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Gas Station
     * - Node Service
     * @param beneficiaryGraphId Id of the beneficiary graph instance.
     * @param beneficiaryAddress Beneficiary address.
     * @returns Transaction digest for this operation.
     */
    setBeneficiary(beneficiaryGraphId, beneficiaryAddress) {
        return this.session.withToken((token) => this.walletClient.setBeneficiary(this.walletId, token, beneficiaryGraphId, beneficiaryAddress));
    }
    /**
     * [Beneficiary Graph API]
     * Clears any beneficiary designation for this wallet in the specified beneficiary graph instance.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Gas Station
     * - Node Service
     * @param beneficiaryGraphId Id of the beneficiary graph instance.
     * @returns Transaction digest for this operation.
     */
    unsetBeneficiary(beneficiaryGraphId) {
        return this.session.withToken((token) => this.walletClient.unsetBeneficiary(this.walletId, token, beneficiaryGraphId));
    }
    /**
     * [Beneficiary Graph API]
     * Gets the beneficiary designation for this wallet in the specified beneficiary graph instance.
     * This is a convenience method on top of suix_getDynamicFieldObject.
     *
     * To call this method, your access key must be authorized for all of these Shinami services:
     * - Wallet Service
     * - Node Service
     * @param beneficiaryGraphId Id of the beneficiary graph instance.
     * @returns Beneficiary address, or null if no beneficiary is designated.
     */
    getBeneficiary(beneficiaryGraphId) {
        return this.walletClient.getBeneficiary(this.walletId, beneficiaryGraphId);
    }
}
/**
 * Offical beneficiary graph id recognized by the Bullshark Quests for point tracking.
 * Must be used with a Mainnet access key.
 */
export const BULLSHARK_QUEST_BENEFICIARY_GRAPH_ID_MAINNET = "0x39fabecb3e74036e6140a938fd1cb194a1affd086004e93c4a76af59d64a2c76";
/**
 * Example beneficiary graph id published on Testnet.
 * Must be used with a Testnet access key.
 */
export const EXAMPLE_BENEFICIARY_GRAPH_ID_TESTNET = "0x1987692739e70cea40e5f2596eee2ebe00bde830f72bb76a7187a0d6d4cea278";

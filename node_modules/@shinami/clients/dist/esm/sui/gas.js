/**
 * Copyright 2023-2024 Shinami Corp.
 * SPDX-License-Identifier: Apache-2.0
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Transaction } from "@mysten/sui/transactions";
import { toB64 } from "@mysten/sui/utils";
import { enums, number, object, optional, string } from "superstruct";
import { ShinamiRpcClient, trimTrailingParams } from "../rpc.js";
import { throwExpression } from "../utils.js";
import { GasStationRpcUrls } from "./endpoints.js";
import { inferRegionalValueFromAccessKey } from "../region.js";
/**
 * A fully sponsored transaction block.
 */
export const SponsoredTransaction = object({
    /**
     * Base64 encoded transaction bytes, including sponsor gas data.
     */
    txBytes: string(),
    /**
     * Transaction digest. Can be used to identify this sponsored transaction.
     */
    txDigest: string(),
    /**
     * Gas owner's signature.
     */
    signature: string(),
    /**
     * Cost breakdown for the sponsor.
     */
    sponsorCost: optional(object({
        computationCost: string(),
        storageCost: string(),
        storageRebate: string(),
    })),
    /**
     * Expiration time of this sponsored transaction, in Unix epoch seconds.
     */
    expireAtTime: optional(number()),
    /**
     * The last Sui epoch this sponsored transaction is valid for.
     */
    expireAfterEpoch: optional(string()),
});
/**
 * The status of a sponsored transaction block.
 */
export const SponsoredTransactionStatus = enums([
    "IN_FLIGHT",
    "COMPLETE",
    "INVALID",
]);
/**
 * The fund information
 */
export const Fund = object({
    network: string(),
    name: string(),
    balance: number(),
    inFlight: number(),
    depositAddress: optional(string()),
});
/**
 * Gas station RPC client.
 */
export class GasStationClient extends ShinamiRpcClient {
    /**
     * @param accessKey Gas access key. Note that the access key also determines which network your
     *    transactions are targeting.
     * @param url Optional URL override.
     */
    constructor(accessKey, url = inferRegionalValueFromAccessKey(accessKey, GasStationRpcUrls, (gasStationRpcUrls) => gasStationRpcUrls.us1)) {
        super(accessKey, url);
    }
    /**
     * Requests sponsorship for a transaction.
     * @param tx Gasless transaction.
     * @returns A fully sponsored transaction block.
     */
    sponsorTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            return this.request("gas_sponsorTransactionBlock", trimTrailingParams([
                tx.txKind,
                (_a = tx.sender) !== null && _a !== void 0 ? _a : throwExpression(new Error("Missing sender")),
                tx.gasBudget,
                tx.gasPrice,
            ]), SponsoredTransaction);
        });
    }
    /**
     * Queries the status of a sponsored transaction block.
     * @param txDigest Sponsored transaction digetst.
     * @returns Sponsored transaction status.
     */
    getSponsoredTransactionStatus(txDigest) {
        return this.request("gas_getSponsoredTransactionBlockStatus", [txDigest], SponsoredTransactionStatus);
    }
    /**
     * Queries the fund associated with the access key.
     * @returns The fund information.
     */
    getFund() {
        return this.request("gas_getFund", [], Fund);
    }
}
/**
 * Builds a gasless transaction.
 * @param txOrBuild Either a `Transaction` object pre-populated with the target transaction data, or
 *    a builder function to populate it.
 * @param options Options
 *    - sender - Optional sender address. Can also be set in the transaction data.
 *    - gasBudget - Optional gas budget. Can also be set in the transaction data.
 *    - gasPrice - Optional gas price. Can also be set in the transaction data.
 *    - sui - `SuiClient`. Required if the transaction uses non fully resolved inputs.
 * @returns A gasless transaction to be sponsored.
 */
export function buildGaslessTransaction(txOrBuild, options) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f;
        let tx;
        if (typeof txOrBuild === "function") {
            tx = new Transaction();
            yield txOrBuild(tx);
        }
        else {
            tx = txOrBuild;
        }
        const txData = tx.getData();
        return {
            txKind: toB64(yield tx.build({ client: options === null || options === void 0 ? void 0 : options.sui, onlyTransactionKind: true })),
            sender: (_b = (_a = options === null || options === void 0 ? void 0 : options.sender) !== null && _a !== void 0 ? _a : txData.sender) !== null && _b !== void 0 ? _b : undefined,
            gasBudget: (_d = (_c = options === null || options === void 0 ? void 0 : options.gasBudget) !== null && _c !== void 0 ? _c : txData.gasData.budget) !== null && _d !== void 0 ? _d : undefined,
            gasPrice: (_f = (_e = options === null || options === void 0 ? void 0 : options.gasPrice) !== null && _e !== void 0 ? _e : txData.gasData.price) !== null && _f !== void 0 ? _f : undefined,
        };
    });
}
